function f2j() {
    # Identificar shell
    if [ -n "$ZSH_VERSION" ]; then
        is_zsh=true
    elif [ -n "$BASH_VERSION" ]; then
        is_bash=true
    else
        echo -e "\033[1;31m‚ùå Erro: Shell n√£o suportado. Use bash ou zsh.\033[0m" >&2
        return 1
    fi

    # Verificar depend√™ncias
    if ! command -v xclip &> /dev/null; then
        echo -e "\033[1;31m‚ùå Erro: xclip n√£o est√° instalado!\033[0m" >&2
        echo "Instale com:" >&2
        echo "  Ubuntu/Debian: sudo apt install xclip" >&2
        echo "  Fedora/RHEL: sudo dnf install xclip" >&2
        echo "  Arch: sudo pacman -S xclip" >&2
        return 1
    fi

    if ! command -v jq &> /dev/null; then
        echo -e "\033[1;31m‚ùå Erro: jq n√£o est√° instalado!\033[0m" >&2
        echo "Instale com:" >&2
        echo "  Ubuntu/Debian: sudo apt install jq" >&2
        echo "  Fedora/RHEL: sudo dnf install jq" >&2
        echo "  Arch: sudo pacman -S jq" >&2
        return 1
    fi

    # Configura√ß√£o de blocos
    typeset -A blocos=(
        [laravel]="README.md .env config/ app/Http/Controllers/ app/Models/ resources/views/ routes/web.php routes/api.php database/migrations/ database/seeders/ composer.json package.json webpack.mix.js public/ routes/ tests/"
        [infra]="Makefile Vagrantfile ansible/ monitoring/ nginx.conf apache2.conf postgresql.conf redis.conf ssl/ vault/"
        [ignorados]="storage/logs/ storage/framework/ vendor/ node_modules/ .git/ .idea/ *.log *.tmp *.swp"
        [docker]="docker/ ./docker-compose.yml ./docker-compose.yaml ./compose.yml ./compose.yaml docker-compose.*.yml docker-compose.*.yaml "
        [all]="."
    )

    typeset -A arquivos_blocos=()
    local outros_arquivos=()
    local arquivos_todos=()
    local goto_processamento_json=false

    # ====================================================
    # L√ìGICA 1: Processamento de STDIN (Pipe)
    # ====================================================
    if [ ! -t 0 ]; then
        # -t 0 verifica se a entrada padr√£o n√£o √© um terminal (pipe)
        local piped_files=()

        # L√™ cada linha do pipe, que s√£o os caminhos dos arquivos do 'tree'
        while IFS= read -r filepath; do
            # Limpeza b√°sica e verifica se √© um arquivo real
            filepath=$(echo "$filepath" | sed 's/^[ \t]*//;s/[ \t]*$//')
            if [ -f "$filepath" ]; then
                piped_files+=("$filepath")
            fi
        done

        if (( ${#piped_files[@]} > 0 )); then
            arquivos_todos=("${piped_files[@]}")
            goto_processamento_json=true
        else
            # Se a entrada for um pipe mas n√£o houver arquivos, retorna erro
            echo -e "\n\033[1;31m‚ùå Nenhum caminho de arquivo v√°lido recebido via pipe!\033[0m" >&2
            return 1
        fi
    fi

    # ====================================================
    # L√ìGICA 2: Mensagem de ajuda e Processamento de Argumentos (se n√£o houver pipe)
    # ====================================================
    if [[ "$goto_processamento_json" == "false" ]]; then
        # Mensagem de ajuda
        if (( $# == 0 )); then
            echo -e "\n\033[1;34müåÄ f2j - Conversor de Arquivos para JSON\033[0m"
            echo "Uso: f2j [blocos] [arquivos/padr√µes]"
            echo -e "\n\033[1;36mBlocos Dispon√≠veis:\033[0m"

            # Listar blocos
            if [ -n "$is_zsh" ]; then
                for bloco in "${(@k)blocos}"; do
                    echo "  $bloco: ${blocos[$bloco]}"
                done | sort
            else
                for bloco in "${!blocos[@]}"; do
                    echo "  $bloco: ${blocos[$bloco]}"
                done | sort
            fi

            echo -e "\n\033[1;36mExemplos:\033[0m"
            echo "  f2j laravel docker *.sh"
            echo "  f2j infra Dockerfile"
            echo "  f2j docker"
            return 1
        fi

        # Processamento de argumentos (blocos e arquivos)
        for arg in "$@"; do
            if [ -n "$is_zsh" ]; then
                # No zsh: verifica√ß√£o de chaves e expans√£o for√ßada de array
                if [[ -v blocos[$arg] ]]; then
                    for caminho in ${=blocos[$arg]}; do
                        # ... (L√≥gica de processamento de caminhos de diret√≥rio/arquivo - OK) ...
                        if [ -d "$caminho" ]; then
                            while IFS= read -r -d $'\00' arquivo; do
                                if [ -z "${arquivos_blocos[$arg]}" ]; then
                                    arquivos_blocos[$arg]="$arquivo"
                                else
                                    arquivos_blocos[$arg]+=$'\00'"$arquivo"
                                fi
                            done < <(find "$caminho" -type f -print0 2>/dev/null)
                        elif [ -f "$caminho" ]; then
                            if [ -z "${arquivos_blocos[$arg]}" ]; then
                                arquivos_blocos[$arg]="$caminho"
                            else
                                arquivos_blocos[$arg]+=$'\00'"$caminho"
                            fi
                        fi
                    done
                fi
            else
                # No bash: verifica√ß√£o de chaves
                if [[ -n "${blocos[$arg]+_}" ]]; then
                    for caminho in ${blocos[$arg]}; do
                        # ... (L√≥gica de processamento de caminhos de diret√≥rio/arquivo - OK) ...
                        if [ -d "$caminho" ]; then
                            while IFS= read -r -d $'\00' arquivo; do
                                if [ -z "${arquivos_blocos[$arg]}" ]; then
                                    arquivos_blocos[$arg]="$arquivo"
                                else
                                    arquivos_blocos[$arg]+=$'\00'"$arquivo"
                                fi
                            done < <(find "$caminho" -type f -print0 2>/dev/null)
                        elif [ -f "$caminho" ]; then
                            if [ -z "${arquivos_blocos[$arg]}" ]; then
                                arquivos_blocos[$arg]="$caminho"
                            else
                                arquivos_blocos[$arg]+=$'\036'"$caminho" # Usando separador de registro (036) para bash
                            fi
                        fi
                    done
                fi
            fi

            # Processa arquivo comum (para ambos shells)
            for file in $arg; do
                [ -f "$file" ] || continue
                outros_arquivos+=("$file")
            done
        done

        # Coleta todos os arquivos (unindo de blocos e argumentos soltos)
        if [ -n "$is_zsh" ]; then
            for bloco in "${(@k)arquivos_blocos}"; do
                IFS=$'\00' read -r -A files_bloco <<< "${arquivos_blocos[$bloco]}"
                arquivos_todos+=("${files_bloco[@]}")
            done
        else
            for bloco in "${!arquivos_blocos[@]}"; do
                # Nota: a leitura em bash √© mais complexa devido ao separador de registro \036
                local files_bloco_str="${arquivos_blocos[$bloco]}"
                while IFS=$'\036' read -r -a files_bloco; do
                    arquivos_todos+=("${files_bloco[@]}")
                done <<< "$files_bloco_str"
            done
        fi
        arquivos_todos+=("${outros_arquivos[@]}")
    fi

    # ====================================================
    # L√ìGICA 3: Processamento JSON e Sa√≠da
    # ====================================================

    # Verifica√ß√£o final de arquivos
    if (( ${#arquivos_todos[@]} == 0 )); then
        echo -e "\n\033[1;31m‚ùå Nenhum arquivo v√°lido para convers√£o encontrado!\\033[0m" >&2
        return 1
    fi

    local json_output=() temp_file=$(mktemp)

    for file in "${arquivos_todos[@]}"; do
        # Evita processar arquivos bin√°rios (grep -Iq: ignora bin√°rios para 'quick' check)
        if grep -Iq . "$file" 2>/dev/null; then
            # Usa jq para ler, converter para string crua (Rs) e criar o objeto JSON
            if content=$(jq -Rs --arg path "$file" '{path: $path, content: .}' < "$file" 2>/dev/null); then
                json_output+=("$content")
            else
                echo -e "\033[33m‚ö†Ô∏è Erro ao processar: $file (Verifique a codifica√ß√£o/permiss√µes)\033[0m" >&2
            fi
        else
            echo -e "\033[33m‚ö†Ô∏è Ignorando bin√°rio: $file\033[0m" >&2
        fi
    done

        
    # Sa√≠da final
    if (( ${#json_output[@]} > 0 )); then
        # Junta todos os objetos JSON em um √∫nico array
        printf '%s\n' "${json_output[@]}" | jq -s '.' > "$temp_file"
        
        # Copia para a √°rea de transfer√™ncia
        xclip -sel c < "$temp_file" 2>/dev/null || echo -e "\033[33m‚ö†Ô∏è xclip n√£o encontrado. O JSON foi salvo em: $temp_file\033[0m" >&2

        echo -e "\n\033[1;34müì¶ Resultados Agrupados:\033[0m"

        # ==========================================================
        # TRECHO MODIFICADO: Exibe os arquivos processados
        # ==========================================================
        if [[ "$goto_processamento_json" == "false" ]]; then
            # L√≥gica original: Listar arquivos por bloco (se vier de argumentos)
            if [ -n "$is_zsh" ]; then
                for bloco in "${(@k)arquivos_blocos}"; do
                    IFS=$'\00' read -r -A files_bloco <<< "${arquivos_blocos[$bloco]}"
                    echo -e "\n\033[1;32m‚óè Bloco [$bloco] (${#files_bloco[@]} arquivos):\\033[0m"
                    printf '%s\n' "${files_bloco[@]}"
                done
            else
                for bloco in "${!arquivos_blocos[@]}"; do
                    local files_bloco_str="${arquivos_blocos[$bloco]}"
                    local count_files_bloco
                    count_files_bloco=$(grep -c $'\036' <<< "$files_bloco_str")
                    echo -e "\n\033[1;32m‚óè Bloco [$bloco] ($((count_files_bloco + 1)) arquivos):\\033[0m"
                    printf '%s\n' "${files_bloco_str//$'\036'/$'\n'}"
                done
            fi
            
            if (( ${#outros_arquivos[@]} > 0 )); then
                echo -e "\n\033[1;32m‚óè Outros Arquivos (${#outros_arquivos[@]}):\\033[0m"
                printf '%s\n' "${outros_arquivos[@]}"
            fi
        else
            # L√≥gica NOVA: Sa√≠da detalhada para o pipe (STDIN)
            echo -e "\n\033[1;32m‚óè Arquivos Recebidos e Processados via Pipe (${#arquivos_todos[@]}):\\033[0m"
            printf '%s\n' "${arquivos_todos[@]}"
        fi
        # ==========================================================

        echo -e "\n\033[1;32m‚úÖ Total de ${#json_output[@]} arquivo(s) convertidos para JSON!\\033[0m"
        echo -e "\033[1;36müìã JSON copiado para √°rea de transfer√™ncia\\033[0m"
    else
        echo -e "\033[1;31m‚ùå Nenhum arquivo v√°lido para convers√£o resultou em JSON!\\033[0m" >&2
        return 1
    fi

    rm -f "$temp_file"
}

function json() {
    f2j "$@"
}
